# -*- coding: utf-8 -*-
"""Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1q1ZzqkxMJ8IKBSsGkmTLs_zPo03cw5tH

"""# Data Processing Functions"""

import pandas as pd
import random

from lxml import html
import requests

# Helper arrays
meals_list = ["Breakfast", "Brunch", "Lunch", "Dinner"]
dh_list = ["Village", "Parkside", "EVK"]

'''
Get today's df_menu from web page, store in dataframe:
    rows = dining hall, columns = meal. Each element is list of foods

Also create today's df_foods, dataframe of foods with allergens and ratings columns
    rows = food item, columns = allergens and ratings

Arguments:
    date: format as [Month] [Day] [Year]. ex: November 17 2019
'''
def initialize_from_page(date="today"):
    # output variables
    df_menu = pd.DataFrame(index = dh_list, columns = meals_list)
    df_foods = pd.DataFrame(columns = ["name", "dh", "allergens", "ratings"])

    # page request
    print("Requesting Page...")
    if (date == "today"):
        page = requests.get('https://hospitality.usc.edu/residential-dining-menus/')
    else:
        d_elem = date.split()
        page = requests.get('https://hospitality.usc.edu/residential-dining-menus/?menu_date='
                            + d_elem[0] + '+' + d_elem[1] + '%2C+' + d_elem[2])

    print("Processing Data...")
    tree = html.fromstring(page.content) # whole page
    meals_html = tree.findall('.//div[@class="hsp-accordian-container"]') # all meals

    # for every meal... (breakfast, brunch, etc.)
    for meal_index, meal in enumerate(meals_html):
        dh_html = meal.findall('.//div[@class="col-sm-6 col-md-4"]') # all dining halls for meal

        # for every dining hall... (Village, Parkside, EVK)
        for dh_index, dh in enumerate(dh_html):
            # set this meal at this dining hall to empty array for holding food
            df_menu.iat[dh_index, meal_index] = []

            foods_html = dh.findall('.//li') # all foods for dining hall for meal

            # for every food...
            for food in foods_html:
                # get allergens for food
                allergens_html = food.findall('.//span')[1:] # all allergens for food for...
                allergens = []

                # get allergens into array
                for allergen in allergens_html:
                    allergens.append(allergen.text)

                # append just the name to menu
                df_menu.iat[dh_index, meal_index].append(food.text)
                #menu[i][j].append({food.text: allergens})

                # add food to df_foods
                curr_dh = dh_list[dh_index]
                df_foods = df_foods.append({"name": food.text, "dh": curr_dh,
                                            "allergens": allergens, "ratings": rand_gen(dh_index, [2,1,0])},
                                           ignore_index=True)


    # remove duplicates from foods list
    df_foods = df_foods.drop_duplicates(['name', 'dh']).sort_values(by=['dh','name'])
    #df_foods = df_foods.reset_index(drop=True)

    # make names the indices
    df_foods = df_foods.set_index('name')

    # update foods with ratings if possible
    #df_foods.update(get_pickle())

    # hummus check (for 17 nov 2019)
    if (len(df_menu["Dinner"]["Village"]) >= 43):
        print("hummus check:", df_menu["Dinner"]["Village"][43])
    else:
        print("df_menu check:", df_menu["Dinner"]["Village"])

    #print("df_foods check:")
    #display(df_foods[:5])

    return df_menu, df_foods

def rand_gen(i, weight_array=[1,2,0]):


    if (i == weight_array[0]):
        return [random.randint(1, 3) for j in range(random.randint(1, 5))]
    elif (i == weight_array[1]):
        return [random.randint(2, 4) for j in range(random.randint(1, 5))]
    elif (i == weight_array[2]):
        return [random.randint(3, 5) for j in range(random.randint(1, 5))]


'''
Examines the database from GitHub, adds rows for foods not already on list.
'''
def update_data(df_foods):
    database = pd.concat([get_pickle().reset_index(), df_foods.reset_index()])
    database = database.drop_duplicates(['name', 'dh'])
    database.update(df_foods)

    return database.set_index('name')#drop('name', axis=1)

'''
saves pickle file locally.
'''
def save_pickle(df, name = "food_list.pkl"):
    pd.to_pickle(df, name)

'''
get the foods pickle (database from GitHub).
'''
def get_pickle():
    return pd.read_pickle("food_list.pkl")




"""# Rating Functions"""

# rate something in df_foods
def rate(rating, food_name):
    df_foods.at[food_name,"rating"] = rating

# evaluate dining hall for a given meal. Give indexes
def evaluate(meal, dh, df_foods):
    total = 0
    count = 0
    df_foods = df_foods.reset_index()

    for food in df_menu.at[dh, meal]:
        ratings = df_foods[(df_foods['name'] == food) & (df_foods['dh'] == dh)]['ratings'].values[0]
        total += sum(ratings)/len(ratings)
        count += 1

    df_foods = df_foods.set_index('name')

    return total/count


def evaluate_all(meal, df_foods):
    dh_ratings = []
    for dh in dh_list:
        dh_ratings.append(evaluate(meal, dh, df_foods))


    return [dh_ratings.index(max(dh_ratings)), dh_ratings]





"""# Main"""

# df_menu and df_foods are based on the date's menu
df_menu, df_foods = initialize_from_page()

# update function updates overall database of foods
database = update_data(df_foods)

df_menu.head()

# Calculate best dining hall
best_brunch = evaluate_all("Brunch", df_foods)[0]
print(dh_list[best_brunch])

#save_pickle(database)






"""## GUI"""
import tkinter as tk
from tkinter import ttk, Button
from tkinter import *
from tkinter.ttk import *

# initializing the window
root = tk.Tk()
root.title("TABS")
# configuring size of the window
root.geometry('800x800')

def create_window():
    New_Window = tk.Tk()
    New_Window.title("POP-UP")
    # configuring size of the window
    New_Window.geometry('440x160')

    ttk.Label(New_Window, text="Message").grid(column=0, row=0)
    add_rating(New_Window)
    ttk.Button(New_Window, text = "Submit", command=New_Window.destroy).grid(column=4, row=2)
    New_Window.mainloop()


def add_rating(New_Window):
    rad1 = Radiobutton(New_Window, text='One Star', value=1)
    rad2 = Radiobutton(New_Window, text='Two Star', value=2)
    rad3 = Radiobutton(New_Window, text='Three Star', value=3)
    rad4 = Radiobutton(New_Window, text='Four Star', value=4)
    rad5 = Radiobutton(New_Window, text='Five Star', value=5)
    rad1.grid(column=0, row=1)
    rad2.grid(column=1, row=1)
    rad3.grid(column=2, row=1)
    rad4.grid(column=3, row=1)
    rad5.grid(column=4, row=1)


#def print_rating():



#Create Tab Control
TAB_CONTROL = ttk.Notebook(root)
#Tab1
TAB1 = ttk.Frame(TAB_CONTROL)
TAB_CONTROL.add(TAB1, text='Recommended')
#Tab2
TAB2 = ttk.Frame(TAB_CONTROL)
TAB_CONTROL.add(TAB2, text='Full Menu')
TAB_CONTROL.pack(expand=1, fill="both")
#Tab Name Labels
ttk.Label(TAB1, text="Best dining hall today is " + dh_list[best_brunch]).grid(column=0, row=1, padx=10, pady=10)

dh_ratings = evaluate_all("Brunch", df_foods)[1]

for i, dh in enumerate(dh_list):
    ttk.Label(TAB1, text=dh + "'s rating today is " + str(round(dh_ratings[i], 2))).grid(column=0, row=2+i, padx=0, pady=0)



btns = []
for i, food in enumerate(df_menu["Brunch"][dh_list[best_brunch]]):
    ttk.Label(TAB2, text = food).grid(column=0, row=i, padx=10, pady=0)


    df_foods = df_foods.reset_index()
    ratings = df_foods[(df_foods['name'] == food) & (df_foods['dh'] == dh_list[best_brunch])]['ratings'].values[0]
    df_foods = df_foods.set_index('name')

    rating = round(sum(ratings)/len(ratings), 2)

    ttk.Label(TAB2, text = rating).grid(column=1, row=i, padx=10, pady=0)
    btns.append(ttk.Button(TAB2, text = "Rate", command=create_window).grid(column=2, row=i, padx=10, pady=0))

#btn1 = ttk.Button(TAB2, text = "Button1", command=create_window).grid(column=0, row=0, padx=10, pady=10)
#Calling Main()
root.mainloop()
